
  move_hand_target(target_position) {
  const current_position = this.human.get_end_effector_position();

  const dx = target_position[0] - current_position[0];
  const dy = target_position[1] - current_position[1];
  const dz = target_position[2] - current_position[2];

  const distance = Math.sqrt(dx**2 + dy**2 + dz**2);

  const delta = [[dx], [dy], [dz]];

  const J = this.human.calculate_Jacobian();
  
  const dtheta = this.human.calculate_delta_theta(J, delta);
  const max_step = Math.min(0.05, Math.max(0.01, distance * 0.1)); 

  for (let i = 0; i < this.human.dof && i < dtheta.length; i++) {
    const change = Math.max(-max_step, Math.min(max_step, dtheta[i][0]));
    this.human.theta[i] += change;
  }

  this.human.apply_theta();
  }


import { mat4 } from 'three/tsl';
import {tiny, defs} from './examples/common.js';
import * as math from 'mathjs';

// Pull these names into this module's scope for convenience:
const { vec3, vec4, color, Mat4, Shape, Material, Shader, Texture, Component } = tiny;

const shapes = {
    'sphere': new defs.Subdivision_Sphere( 5 ),
};


class Node {
    constructor(name, shape, transform) {
        this.name = name;
        this.shape = shape;
        this.transform_matrix = transform;
        this.children_arcs = [];
    }
}

class Arc {
    constructor(name, parent, child, location) {
        this.name = name;
        this.parent_node = parent;
        this.child_node = child;
        this.location_matrix = location;
        this.articulation_matrix = Mat4.identity();
        this.end_effector = null;
        // Here I only implement rotational DOF
        this.dof = {
            Rx: false,
            Ry: false,
            Rz: false,
        }
    }

    set_dof(x, y, z) {
        this.dof.Rx = x;
        this.dof.Ry = y;
        this.dof.Rz = z;
    }

    update_articulation(theta) {
        this.articulation_matrix = Mat4.identity();
        let index = 0;
        if (this.dof.Rx) {
            this.articulation_matrix.pre_multiply(Mat4.rotation(theta[index], 1, 0, 0));
            index += 1;
        }
        if (this.dof.Ry) {
            this.articulation_matrix.pre_multiply(Mat4.rotation(theta[index], 0, 1, 0));
            index += 1;
        }
        if (this.dof.Rz) {
            this.articulation_matrix.pre_multiply(Mat4.rotation(theta[index], 0, 0, 1));
        }
    }
}

class RootTranlation extends Arc {
    constructor(name, parent, child, location) {
        super(name, parent, child, location);
        this.set_dof(false, false, false);
        this.translation = true;
    }
}

class RotArc3D extends Arc {
    constructor(name, parent, child, location) {
        super(name, parent, child, location);
        this.set_dof(true, true, true);
    }
}

class RotArc2D_xy extends Arc {
    constructor(name, parent, child, location) {
        super(name, parent, child, location);
        this.set_dof(true, true, false);
    }
}

class RotArc2D_yz extends Arc {
    constructor(name, parent, child, location) {
        super(name, parent, child, location);
        this.set_dof(false, true, true);
    }
}

// You are absoulutely free to modify this class, or add more classes.
class End_Effector {
    constructor(name, parent, local_position) {
        this.name = name;
        this.parent = parent;
        this.local_position = local_position;
        this.global_position = null;
    }
}

export
const Articulated_Human = 
class Articulated_Human {
    constructor() {
        const sphere_shape = shapes.sphere;

        // torso node
        const torso_transform = Mat4.scale(1, 2.5, 0.5);
        this.torso_node = new Node("torso", sphere_shape, torso_transform);

        // root->torso: Translation
        const root_location = Mat4.translation(0, 5, 5);
        this.root = new RootTranlation("root", null, this.torso_node, root_location);

        // head node
        let head_transform = Mat4.scale(.6, .6, .6);
        head_transform.pre_multiply(Mat4.translation(0, .6, 0));
        this.head_node = new Node("head", sphere_shape, head_transform);

        // torso->neck->head
        const neck_location = Mat4.translation(0, 2.5, 0);
        this.neck = new Arc("neck", this.torso_node, this.head_node, neck_location);
        this.torso_node.children_arcs.push(this.neck);

        // right upper arm node
        let ru_arm_transform = Mat4.scale(1.2, .2, .2);
        ru_arm_transform.pre_multiply(Mat4.translation(1.2, 0, 0));
        this.ru_arm_node = new Node("ru_arm", sphere_shape, ru_arm_transform);

        // torso->r_shoulder->ru_arm: 3D Rotation
        const r_shoulder_location = Mat4.translation(0.6, 2, 0);
        this.r_shoulder = new RotArc3D("r_shoulder", this.torso_node, this.ru_arm_node, r_shoulder_location);
        this.torso_node.children_arcs.push(this.r_shoulder)

        // right lower arm node
        let rl_arm_transform = Mat4.scale(1, .2, .2);
        rl_arm_transform.pre_multiply(Mat4.translation(1, 0, 0));
        this.rl_arm_node = new Node("rl_arm", sphere_shape, rl_arm_transform);

        // ru_arm->r_elbow->rl_arm: xy
        const r_elbow_location = Mat4.translation(2.4, 0, 0);
        this.r_elbow = new RotArc2D_xy("r_elbow", this.ru_arm_node, this.rl_arm_node, r_elbow_location);
        this.ru_arm_node.children_arcs.push(this.r_elbow)

        // right hand node
        let r_hand_transform = Mat4.scale(.4, .3, .2);
        r_hand_transform.pre_multiply(Mat4.translation(0.4, 0, 0));
        this.r_hand_node = new Node("r_hand", sphere_shape, r_hand_transform);

        // rl_arm->r_wrist->r_hand: yz Rotation
        const r_wrist_location = Mat4.translation(2, 0, 0);
        this.r_wrist = new RotArc2D_yz("r_wrist", this.rl_arm_node, this.r_hand_node, r_wrist_location);
        this.rl_arm_node.children_arcs.push(this.r_wrist);

        // add the only end-effector
        const r_hand_end_local_pos = vec4(0.8, 0, 0, 1);
        this.end_effector = new End_Effector("right_hand", this.r_hand_node, r_hand_end_local_pos);
        this.r_hand_node.end_effector = this.end_effector;

        // left upper arm node
        let lu_arm_transform = Mat4.scale(1.2, .2, .2);
        lu_arm_transform.pre_multiply(Mat4.translation(-1.2, 0, 0));
        this.lu_arm_node = new Node("lu_arm", sphere_shape, lu_arm_transform);

        // torso->l_shoulder->lu_arm
        const l_shoulder_location = Mat4.translation(-0.6, 2, 0);
        this.l_shoulder = new Arc("l_shoulder", this.torso_node, this.lu_arm_node, l_shoulder_location);
        this.torso_node.children_arcs.push(this.l_shoulder);

        // left lower arm node
        let ll_arm_transform = Mat4.scale(1, .2, .2);
        ll_arm_transform.pre_multiply(Mat4.translation(-1, 0, 0));
        this.ll_arm_node = new Node("ll_arm", sphere_shape, ll_arm_transform);

        // lu_arm->l_elbow->ll_arm
        const l_elbow_location = Mat4.translation(-2.4, 0, 0);
        this.l_elbow = new Arc("l_elbow", this.lu_arm_node, this.ll_arm_node, l_elbow_location);
        this.lu_arm_node.children_arcs.push(this.l_elbow);

        // left hand node
        let l_hand_transform = Mat4.scale(.4, .3, .2);
        l_hand_transform.pre_multiply(Mat4.translation(-0.4, 0, 0));
        this.l_hand_node = new Node("l_hand", sphere_shape, l_hand_transform);

        // ll_arm->l_wrist->l_hand
        const l_wrist_location = Mat4.translation(-2, 0, 0);
        this.l_wrist = new Arc("l_wrist", this.ll_arm_node, this.l_hand_node, l_wrist_location);
        this.ll_arm_node.children_arcs.push(this.l_wrist);

        // right thigh node
        let r_thigh_transform = Mat4.scale(0.35, 1, 0.35);
        r_thigh_transform.pre_multiply(Mat4.translation(0.2, -0.95, 0));
        this.r_thigh_node = new Node("r_thigh", sphere_shape, r_thigh_transform);

        // torso->r_hip->r_thigh
        const r_hip_location = Mat4.translation(0.2, -2.4, 0);
        this.r_hip = new Arc("r_hip", this.torso_node, this.r_thigh_node, r_hip_location);
        this.torso_node.children_arcs.push(this.r_hip);

        // right calf node
        let r_calf_transform = Mat4.scale(0.3, 0.5, 0.3);
        r_calf_transform.pre_multiply(Mat4.translation(0.2, -0.05, 0));
        this.r_calf_node = new Node("r_calf", sphere_shape, r_calf_transform);

        // r_thigh->r_knee->r_calf
        const r_knee_location = Mat4.translation(0, -2.4, 0);
        this.r_knee = new Arc("r_knee", this.r_thigh_node, this.r_calf_node, r_knee_location);
        this.r_thigh_node.children_arcs.push(this.r_knee);

        // right foot node
        let r_foot_transform = Mat4.scale(0.35, 0.2, 0.5);
        r_foot_transform.pre_multiply(Mat4.translation(0.2, -0.2, -0.3));
        this.r_foot_node = new Node("r_foot", sphere_shape, r_foot_transform);

        // r_calf->r_ankle->r_foot
        const r_ankle_location = Mat4.translation(0, -0.4, 0);
        this.r_ankle = new Arc("r_ankle", this.r_calf_node, this.r_foot_node, r_ankle_location);
        this.r_calf_node.children_arcs.push(this.r_ankle);

        // left thigh node
        let l_thigh_transform = Mat4.scale(0.35, 1, 0.35);
        l_thigh_transform.pre_multiply(Mat4.translation(-0.2, -0.95, 0));
        this.l_thigh_node = new Node("l_thigh", sphere_shape, l_thigh_transform);

        // torso->l_hip->l_thigh
        const l_hip_location = Mat4.translation(-0.2, -2.4, 0);
        this.l_hip = new Arc("l_hip", this.torso_node, this.l_thigh_node, l_hip_location);
        this.torso_node.children_arcs.push(this.l_hip);

        // left calf node
        let l_calf_transform = Mat4.scale(0.3, 0.5, 0.3);
        l_calf_transform.pre_multiply(Mat4.translation(-0.2, -0.05, 0));
        this.l_calf_node = new Node("l_calf", sphere_shape, l_calf_transform);

        // l_thigh->l_knee->l_calf
        const l_knee_location = Mat4.translation(0, -2.4, 0);
        this.l_knee = new Arc("l_knee", this.l_thigh_node, this.l_calf_node, l_knee_location);
        this.l_thigh_node.children_arcs.push(this.l_knee);

        // left foot node
        let l_foot_transform = Mat4.scale(0.35, 0.2, 0.5);
        l_foot_transform.pre_multiply(Mat4.translation(-0.2, -0.2, -0.3));
        this.l_foot_node = new Node("l_foot", sphere_shape, l_foot_transform);

        // l_calf->l_ankle->l_foot
        const l_ankle_location = Mat4.translation(0, -0.4, 0);
        this.l_ankle = new Arc("l_ankle", this.l_calf_node, this.l_foot_node, l_ankle_location);
        this.l_calf_node.children_arcs.push(this.l_ankle);

        // 10 dof
        this.dof = 10;
        this.Jacobian = null;
        this.theta = new Array(10).fill(0);
        this.apply_theta();
    }

    // mapping from global theta to each joint theta
    apply_theta() {
       const tx = this.theta[0];
       const ty = this.theta[1];
       const tz = this.theta[2]
       this.root.location_matrix = Mat4.translation(tx, ty + 5, tz + 1);
    
       const shoulder_theta = [this.theta[3], this.theta[4], this.theta[5]];
       this.r_shoulder.update_articulation(shoulder_theta);

       const elbow_theta = [this.theta[6], this.theta[7]];
       this.r_elbow.update_articulation(elbow_theta);

       const wrist_theta = [this.theta[8], this.theta[9]];
       this.r_wrist.update_articulation(wrist_theta);
    }

    calculate_Jacobian() {
        let J = new Array(3);
        for (let i = 0; i < 3; i++) {
            J[i] = new Array(this.dof).fill(0);
        }
        
        const current_position = this.get_end_effector_position();

        const h = 0.001;

        for (let i = 0; i < this.dof; i++) {
            const current_theta = this.theta[i];
            this.theta[i] = current_theta + h;
            this.apply_theta();

            const changed_position = this.get_end_effector_position();

            J[0][i] = (changed_position[0] - current_position[0]) / h;
            J[1][i] = (changed_position[1] - current_position[1]) / h;
            J[2][i] = (changed_position[2] - current_position[2]) / h;

            this.theta[i] = current_theta;
            this.apply_theta();
        }

        return J; 
    }

    calculate_delta_theta(J, dx) {
        const A = math.multiply(math.transpose(J), J);

        for (let i = 0; i < A.length; i++)
            A[i][i] += 0.05;

        const b = math.multiply(math.transpose(J), dx);
        const x = math.lusolve(A, b);

        const max_step = 0.08;
        for (let i = 0; i < x.length; i++) {
            if (x[i][0] > max_step)
                x[i][0] = max_step;
            if (x[i][0] < -max_step)
                x[i][0] = -max_step;
        }

        return x;
    }

    get_end_effector_position() {
        // in this example, we only have one end effector.
        this.matrix_stack = [];
        this._rec_update(this.root, Mat4.identity());
        const v = this.end_effector.global_position; // vec4
        return vec3(v[0], v[1], v[2]);
    }

    _rec_update(arc, matrix) {
        if (arc != null) {
            const L = arc.location_matrix;
            const A = arc.articulation_matrix;
            const combined_matrix = matrix.times(L.times(A));

            const node = arc.child_node;
            const T = node.transform_matrix;
            const node_matrix = combined_matrix.times(T)

            if (node.end_effector != null) {
                node.end_effector.global_position = node_matrix.times(node.end_effector.local_position);
            }

            for (const next_arc of node.children_arcs) {
                 this._rec_update(next_arc, combined_matrix);
            }
        }
    }

    draw(webgl_manager, uniforms, material) {
        this.matrix_stack = [];
        this._rec_draw(this.root, Mat4.identity(), webgl_manager, uniforms, material);
    }

    _rec_draw(arc, matrix, webgl_manager, uniforms, material) {
        if (arc !== null) {
            const L = arc.location_matrix;
            const A = arc.articulation_matrix;
            matrix.post_multiply(L.times(A));
            this.matrix_stack.push(matrix.copy());

            const node = arc.child_node;
            const T = node.transform_matrix;
            matrix.post_multiply(T);
            node.shape.draw(webgl_manager, uniforms, matrix, material);

            matrix = this.matrix_stack.pop();
            for (const next_arc of node.children_arcs) {
                this.matrix_stack.push(matrix.copy());
                this._rec_draw(next_arc, matrix, webgl_manager, uniforms, material);
                matrix = this.matrix_stack.pop();
            }
        }
    }

    debug(arc=null, id=null) {
        const J = this.calculate_Jacobian();

        let dx = [[0], [-0.02], [0]];
        if (id === 2)
            dx = [[-0.02], [0], [0]];

        const dtheta = this.calculate_delta_theta(J, dx);

        for (let i = 0; i < this.dof && i < dtheta.length; i++)
            this.theta[i] += dtheta[i][0];

        this.apply_theta();
    }
}
